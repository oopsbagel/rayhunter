use anyhow::{Result, bail};
use libc::{c_char, c_int, c_uchar, c_ulong, ioctl, open};

const SG_IO: c_ulong = 0x2285;
const OPEN_FLAGS: c_int = 0x0802; // O_RDWR|O_NONLOCK

pub async fn install(device: String) -> Result<()> {
    // Vendor specific debug switch
    // 0x16 ... messages are reserved per https://www.t10.org/lists/op-num.htm
    #[rustfmt::skip]
    let cmd: [c_uchar; 16] = [
        0x16, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    // sg_io_hdr from <scsi/sg.h>
    // ioctl(3, SG_IO, {
    //   interface_id='S', dxfer_direction=SG_DXFER_NONE, cmd_len=16,
    //   cmdp="\x16\xf9\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
    //   mx_sb_len=32, iovec_count=0, dxfer_len=0, timeout=20000,
    //   flags=0, status=0, masked_status=0, msg_status=0, sb_len_wr=0, sbp="",
    //   host_status=0, driver_status=0, resid=0, duration=3,
    //   info=0
    // }) = 0
    #[rustfmt::skip]
    let mut sg_io_hdr: [c_uchar; 88] = [
        0x53, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xab, 0xac, 0xfe, 0xca, 0xab, 0xac, 0xfe, 0xca, // cmdp; void* cmd
        0xab, 0xac, 0xab, 0xac, 0xab, 0xac, 0xab, 0xac, // sbp; don't care
        0x20, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    unsafe {
        let fd = open(device.as_ptr() as *const c_char, OPEN_FLAGS);
        let cmdp = (&raw const cmd as u64).to_le_bytes();
        sg_io_hdr[24..32].copy_from_slice(&cmdp);
        match ioctl(fd, SG_IO, &sg_io_hdr) == 0 {
            true => Ok(()),
            false => bail!("ioctl(fd, SG_IO, &sg_io_hdr) failed"),
        }
    }
}
